// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: seqsvr.tl.proto

package seqsvr

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN                    TLConstructor = 0
	CRC32_int32V                     TLConstructor = -816401434
	CRC32_int64V                     TLConstructor = 1560852317
	CRC32_boolFalse2                 TLConstructor = -1551878720
	CRC32_boolTrue2                  TLConstructor = -466523818
	CRC32_void                       TLConstructor = 852168407
	CRC32_nodeAddrInfo               TLConstructor = 1327779405
	CRC32_rangeId                    TLConstructor = 753683407
	CRC32_routerNode                 TLConstructor = -494247970
	CRC32_router                     TLConstructor = -1308968200
	CRC32_setNodeInfo                TLConstructor = -2003449992
	CRC32_setNodeInfoList            TLConstructor = 260619155
	CRC32_perSetRouterTable          TLConstructor = -720815251
	CRC32_sequence                   TLConstructor = 1719366935
	CRC32_maxSeqsData                TLConstructor = 1841312951
	CRC32_alloc_fetchNextSequence    TLConstructor = -580368098
	CRC32_alloc_getCurrentSequence   TLConstructor = 1382426801
	CRC32_store_loadMaxSeqsData      TLConstructor = -540991348
	CRC32_store_saveMaxSeq           TLConstructor = 95451525
	CRC32_store_loadRouteTable       TLConstructor = -857598577
	CRC32_store_saveRouteTable       TLConstructor = 1038739636
	CRC32_mediate_registerAllocSvr   TLConstructor = -1497386444
	CRC32_mediate_unRegisterAllocSvr TLConstructor = 1637414201
)

var TLConstructor_name = map[int32]string{
	0:           "CRC32_UNKNOWN",
	-816401434:  "CRC32_int32V",
	1560852317:  "CRC32_int64V",
	-1551878720: "CRC32_boolFalse2",
	-466523818:  "CRC32_boolTrue2",
	852168407:   "CRC32_void",
	1327779405:  "CRC32_nodeAddrInfo",
	753683407:   "CRC32_rangeId",
	-494247970:  "CRC32_routerNode",
	-1308968200: "CRC32_router",
	-2003449992: "CRC32_setNodeInfo",
	260619155:   "CRC32_setNodeInfoList",
	-720815251:  "CRC32_perSetRouterTable",
	1719366935:  "CRC32_sequence",
	1841312951:  "CRC32_maxSeqsData",
	-580368098:  "CRC32_alloc_fetchNextSequence",
	1382426801:  "CRC32_alloc_getCurrentSequence",
	-540991348:  "CRC32_store_loadMaxSeqsData",
	95451525:    "CRC32_store_saveMaxSeq",
	-857598577:  "CRC32_store_loadRouteTable",
	1038739636:  "CRC32_store_saveRouteTable",
	-1497386444: "CRC32_mediate_registerAllocSvr",
	1637414201:  "CRC32_mediate_unRegisterAllocSvr",
}

var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN":                    0,
	"CRC32_int32V":                     -816401434,
	"CRC32_int64V":                     1560852317,
	"CRC32_boolFalse2":                 -1551878720,
	"CRC32_boolTrue2":                  -466523818,
	"CRC32_void":                       852168407,
	"CRC32_nodeAddrInfo":               1327779405,
	"CRC32_rangeId":                    753683407,
	"CRC32_routerNode":                 -494247970,
	"CRC32_router":                     -1308968200,
	"CRC32_setNodeInfo":                -2003449992,
	"CRC32_setNodeInfoList":            260619155,
	"CRC32_perSetRouterTable":          -720815251,
	"CRC32_sequence":                   1719366935,
	"CRC32_maxSeqsData":                1841312951,
	"CRC32_alloc_fetchNextSequence":    -580368098,
	"CRC32_alloc_getCurrentSequence":   1382426801,
	"CRC32_store_loadMaxSeqsData":      -540991348,
	"CRC32_store_saveMaxSeq":           95451525,
	"CRC32_store_loadRouteTable":       -857598577,
	"CRC32_store_saveRouteTable":       1038739636,
	"CRC32_mediate_registerAllocSvr":   -1497386444,
	"CRC32_mediate_unRegisterAllocSvr": 1637414201,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}

func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{0}
}

// Bool2 <--
//  + TL_boolFalse2
//  + TL_boolTrue2
//
type Bool2 struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Bool2) Reset()         { *m = Bool2{} }
func (m *Bool2) String() string { return proto.CompactTextString(m) }
func (*Bool2) ProtoMessage()    {}
func (*Bool2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{0}
}
func (m *Bool2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bool2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bool2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bool2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bool2.Merge(m, src)
}
func (m *Bool2) XXX_Size() int {
	return m.Size()
}
func (m *Bool2) XXX_DiscardUnknown() {
	xxx_messageInfo_Bool2.DiscardUnknown(m)
}

var xxx_messageInfo_Bool2 proto.InternalMessageInfo

func (m *Bool2) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *Bool2) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

type TLBoolFalse2 struct {
	Data2                *Bool2   `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLBoolFalse2) Reset()         { *m = TLBoolFalse2{} }
func (m *TLBoolFalse2) String() string { return proto.CompactTextString(m) }
func (*TLBoolFalse2) ProtoMessage()    {}
func (*TLBoolFalse2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{1}
}
func (m *TLBoolFalse2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBoolFalse2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBoolFalse2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBoolFalse2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBoolFalse2.Merge(m, src)
}
func (m *TLBoolFalse2) XXX_Size() int {
	return m.Size()
}
func (m *TLBoolFalse2) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBoolFalse2.DiscardUnknown(m)
}

var xxx_messageInfo_TLBoolFalse2 proto.InternalMessageInfo

func (m *TLBoolFalse2) GetData2() *Bool2 {
	if m != nil {
		return m.Data2
	}
	return nil
}

type TLBoolTrue2 struct {
	Data2                *Bool2   `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLBoolTrue2) Reset()         { *m = TLBoolTrue2{} }
func (m *TLBoolTrue2) String() string { return proto.CompactTextString(m) }
func (*TLBoolTrue2) ProtoMessage()    {}
func (*TLBoolTrue2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{2}
}
func (m *TLBoolTrue2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBoolTrue2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBoolTrue2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBoolTrue2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBoolTrue2.Merge(m, src)
}
func (m *TLBoolTrue2) XXX_Size() int {
	return m.Size()
}
func (m *TLBoolTrue2) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBoolTrue2.DiscardUnknown(m)
}

var xxx_messageInfo_TLBoolTrue2 proto.InternalMessageInfo

func (m *TLBoolTrue2) GetData2() *Bool2 {
	if m != nil {
		return m.Data2
	}
	return nil
}

// Int32V <--
//  + TL_int32V
//
type Int32V struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	V                    int32         `protobuf:"varint,3,opt,name=v,proto3" json:"v,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Int32V) Reset()         { *m = Int32V{} }
func (m *Int32V) String() string { return proto.CompactTextString(m) }
func (*Int32V) ProtoMessage()    {}
func (*Int32V) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{3}
}
func (m *Int32V) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Int32V) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Int32V.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Int32V) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int32V.Merge(m, src)
}
func (m *Int32V) XXX_Size() int {
	return m.Size()
}
func (m *Int32V) XXX_DiscardUnknown() {
	xxx_messageInfo_Int32V.DiscardUnknown(m)
}

var xxx_messageInfo_Int32V proto.InternalMessageInfo

func (m *Int32V) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *Int32V) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *Int32V) GetV() int32 {
	if m != nil {
		return m.V
	}
	return 0
}

type TLInt32V struct {
	Data2                *Int32V  `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLInt32V) Reset()         { *m = TLInt32V{} }
func (m *TLInt32V) String() string { return proto.CompactTextString(m) }
func (*TLInt32V) ProtoMessage()    {}
func (*TLInt32V) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{4}
}
func (m *TLInt32V) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInt32V) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInt32V.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInt32V) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInt32V.Merge(m, src)
}
func (m *TLInt32V) XXX_Size() int {
	return m.Size()
}
func (m *TLInt32V) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInt32V.DiscardUnknown(m)
}

var xxx_messageInfo_TLInt32V proto.InternalMessageInfo

func (m *TLInt32V) GetData2() *Int32V {
	if m != nil {
		return m.Data2
	}
	return nil
}

// Int64V <--
//  + TL_int64V
//
type Int64V struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	V                    int64         `protobuf:"varint,3,opt,name=v,proto3" json:"v,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Int64V) Reset()         { *m = Int64V{} }
func (m *Int64V) String() string { return proto.CompactTextString(m) }
func (*Int64V) ProtoMessage()    {}
func (*Int64V) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{5}
}
func (m *Int64V) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Int64V) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Int64V.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Int64V) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int64V.Merge(m, src)
}
func (m *Int64V) XXX_Size() int {
	return m.Size()
}
func (m *Int64V) XXX_DiscardUnknown() {
	xxx_messageInfo_Int64V.DiscardUnknown(m)
}

var xxx_messageInfo_Int64V proto.InternalMessageInfo

func (m *Int64V) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *Int64V) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *Int64V) GetV() int64 {
	if m != nil {
		return m.V
	}
	return 0
}

type TLInt64V struct {
	Data2                *Int64V  `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLInt64V) Reset()         { *m = TLInt64V{} }
func (m *TLInt64V) String() string { return proto.CompactTextString(m) }
func (*TLInt64V) ProtoMessage()    {}
func (*TLInt64V) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{6}
}
func (m *TLInt64V) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInt64V) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInt64V.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInt64V) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInt64V.Merge(m, src)
}
func (m *TLInt64V) XXX_Size() int {
	return m.Size()
}
func (m *TLInt64V) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInt64V.DiscardUnknown(m)
}

var xxx_messageInfo_TLInt64V proto.InternalMessageInfo

func (m *TLInt64V) GetData2() *Int64V {
	if m != nil {
		return m.Data2
	}
	return nil
}

// MaxSeqsData <--
//  + TL_maxSeqsData
//
type MaxSeqsData struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	SetId                *RangeId      `protobuf:"bytes,3,opt,name=set_id,json=setId,proto3" json:"set_id,omitempty"`
	MaxSeqs              []int64       `protobuf:"varint,4,rep,packed,name=max_seqs,json=maxSeqs,proto3" json:"max_seqs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *MaxSeqsData) Reset()         { *m = MaxSeqsData{} }
func (m *MaxSeqsData) String() string { return proto.CompactTextString(m) }
func (*MaxSeqsData) ProtoMessage()    {}
func (*MaxSeqsData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{7}
}
func (m *MaxSeqsData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxSeqsData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxSeqsData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxSeqsData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxSeqsData.Merge(m, src)
}
func (m *MaxSeqsData) XXX_Size() int {
	return m.Size()
}
func (m *MaxSeqsData) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxSeqsData.DiscardUnknown(m)
}

var xxx_messageInfo_MaxSeqsData proto.InternalMessageInfo

func (m *MaxSeqsData) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *MaxSeqsData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *MaxSeqsData) GetSetId() *RangeId {
	if m != nil {
		return m.SetId
	}
	return nil
}

func (m *MaxSeqsData) GetMaxSeqs() []int64 {
	if m != nil {
		return m.MaxSeqs
	}
	return nil
}

type TLMaxSeqsData struct {
	Data2                *MaxSeqsData `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TLMaxSeqsData) Reset()         { *m = TLMaxSeqsData{} }
func (m *TLMaxSeqsData) String() string { return proto.CompactTextString(m) }
func (*TLMaxSeqsData) ProtoMessage()    {}
func (*TLMaxSeqsData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{8}
}
func (m *TLMaxSeqsData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMaxSeqsData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMaxSeqsData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMaxSeqsData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMaxSeqsData.Merge(m, src)
}
func (m *TLMaxSeqsData) XXX_Size() int {
	return m.Size()
}
func (m *TLMaxSeqsData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMaxSeqsData.DiscardUnknown(m)
}

var xxx_messageInfo_TLMaxSeqsData proto.InternalMessageInfo

func (m *TLMaxSeqsData) GetData2() *MaxSeqsData {
	if m != nil {
		return m.Data2
	}
	return nil
}

// NodeAddrInfo <--
//  + TL_nodeAddrInfo
//
type NodeAddrInfo struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	Ip                   string        `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty"`
	Port                 int32         `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *NodeAddrInfo) Reset()         { *m = NodeAddrInfo{} }
func (m *NodeAddrInfo) String() string { return proto.CompactTextString(m) }
func (*NodeAddrInfo) ProtoMessage()    {}
func (*NodeAddrInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{9}
}
func (m *NodeAddrInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAddrInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeAddrInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeAddrInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAddrInfo.Merge(m, src)
}
func (m *NodeAddrInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeAddrInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAddrInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAddrInfo proto.InternalMessageInfo

func (m *NodeAddrInfo) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *NodeAddrInfo) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *NodeAddrInfo) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *NodeAddrInfo) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type TLNodeAddrInfo struct {
	Data2                *NodeAddrInfo `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLNodeAddrInfo) Reset()         { *m = TLNodeAddrInfo{} }
func (m *TLNodeAddrInfo) String() string { return proto.CompactTextString(m) }
func (*TLNodeAddrInfo) ProtoMessage()    {}
func (*TLNodeAddrInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{10}
}
func (m *TLNodeAddrInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLNodeAddrInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLNodeAddrInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLNodeAddrInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLNodeAddrInfo.Merge(m, src)
}
func (m *TLNodeAddrInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLNodeAddrInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLNodeAddrInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLNodeAddrInfo proto.InternalMessageInfo

func (m *TLNodeAddrInfo) GetData2() *NodeAddrInfo {
	if m != nil {
		return m.Data2
	}
	return nil
}

// PerSetRouterTable <--
//  + TL_perSetRouterTable
//
type PerSetRouterTable struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	SetId                *RangeId      `protobuf:"bytes,3,opt,name=set_id,json=setId,proto3" json:"set_id,omitempty"`
	NodeList             []*RouterNode `protobuf:"bytes,4,rep,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PerSetRouterTable) Reset()         { *m = PerSetRouterTable{} }
func (m *PerSetRouterTable) String() string { return proto.CompactTextString(m) }
func (*PerSetRouterTable) ProtoMessage()    {}
func (*PerSetRouterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{11}
}
func (m *PerSetRouterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerSetRouterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerSetRouterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerSetRouterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerSetRouterTable.Merge(m, src)
}
func (m *PerSetRouterTable) XXX_Size() int {
	return m.Size()
}
func (m *PerSetRouterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_PerSetRouterTable.DiscardUnknown(m)
}

var xxx_messageInfo_PerSetRouterTable proto.InternalMessageInfo

func (m *PerSetRouterTable) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *PerSetRouterTable) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *PerSetRouterTable) GetSetId() *RangeId {
	if m != nil {
		return m.SetId
	}
	return nil
}

func (m *PerSetRouterTable) GetNodeList() []*RouterNode {
	if m != nil {
		return m.NodeList
	}
	return nil
}

type TLPerSetRouterTable struct {
	Data2                *PerSetRouterTable `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLPerSetRouterTable) Reset()         { *m = TLPerSetRouterTable{} }
func (m *TLPerSetRouterTable) String() string { return proto.CompactTextString(m) }
func (*TLPerSetRouterTable) ProtoMessage()    {}
func (*TLPerSetRouterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{12}
}
func (m *TLPerSetRouterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLPerSetRouterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLPerSetRouterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLPerSetRouterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLPerSetRouterTable.Merge(m, src)
}
func (m *TLPerSetRouterTable) XXX_Size() int {
	return m.Size()
}
func (m *TLPerSetRouterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_TLPerSetRouterTable.DiscardUnknown(m)
}

var xxx_messageInfo_TLPerSetRouterTable proto.InternalMessageInfo

func (m *TLPerSetRouterTable) GetData2() *PerSetRouterTable {
	if m != nil {
		return m.Data2
	}
	return nil
}

// RangeId <--
//  + TL_rangeId
//
type RangeId struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	IdBegin              int32         `protobuf:"varint,3,opt,name=id_begin,json=idBegin,proto3" json:"id_begin,omitempty"`
	Size2                int32         `protobuf:"varint,4,opt,name=size2,proto3" json:"size2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RangeId) Reset()         { *m = RangeId{} }
func (m *RangeId) String() string { return proto.CompactTextString(m) }
func (*RangeId) ProtoMessage()    {}
func (*RangeId) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{13}
}
func (m *RangeId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangeId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeId.Merge(m, src)
}
func (m *RangeId) XXX_Size() int {
	return m.Size()
}
func (m *RangeId) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeId.DiscardUnknown(m)
}

var xxx_messageInfo_RangeId proto.InternalMessageInfo

func (m *RangeId) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *RangeId) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *RangeId) GetIdBegin() int32 {
	if m != nil {
		return m.IdBegin
	}
	return 0
}

func (m *RangeId) GetSize2() int32 {
	if m != nil {
		return m.Size2
	}
	return 0
}

type TLRangeId struct {
	Data2                *RangeId `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLRangeId) Reset()         { *m = TLRangeId{} }
func (m *TLRangeId) String() string { return proto.CompactTextString(m) }
func (*TLRangeId) ProtoMessage()    {}
func (*TLRangeId) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{14}
}
func (m *TLRangeId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRangeId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRangeId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRangeId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRangeId.Merge(m, src)
}
func (m *TLRangeId) XXX_Size() int {
	return m.Size()
}
func (m *TLRangeId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRangeId.DiscardUnknown(m)
}

var xxx_messageInfo_TLRangeId proto.InternalMessageInfo

func (m *TLRangeId) GetData2() *RangeId {
	if m != nil {
		return m.Data2
	}
	return nil
}

// Router <--
//  + TL_router
//
type Router struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	Version              int32         `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	NodeList             []*RouterNode `protobuf:"bytes,4,rep,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Router) Reset()         { *m = Router{} }
func (m *Router) String() string { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()    {}
func (*Router) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{15}
}
func (m *Router) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Router) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Router.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Router) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Router.Merge(m, src)
}
func (m *Router) XXX_Size() int {
	return m.Size()
}
func (m *Router) XXX_DiscardUnknown() {
	xxx_messageInfo_Router.DiscardUnknown(m)
}

var xxx_messageInfo_Router proto.InternalMessageInfo

func (m *Router) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *Router) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *Router) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Router) GetNodeList() []*RouterNode {
	if m != nil {
		return m.NodeList
	}
	return nil
}

type TLRouter struct {
	Data2                *Router  `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLRouter) Reset()         { *m = TLRouter{} }
func (m *TLRouter) String() string { return proto.CompactTextString(m) }
func (*TLRouter) ProtoMessage()    {}
func (*TLRouter) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{16}
}
func (m *TLRouter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRouter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRouter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRouter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRouter.Merge(m, src)
}
func (m *TLRouter) XXX_Size() int {
	return m.Size()
}
func (m *TLRouter) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRouter.DiscardUnknown(m)
}

var xxx_messageInfo_TLRouter proto.InternalMessageInfo

func (m *TLRouter) GetData2() *Router {
	if m != nil {
		return m.Data2
	}
	return nil
}

// RouterNode <--
//  + TL_routerNode
//
type RouterNode struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	NodeAddr             *NodeAddrInfo `protobuf:"bytes,3,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	SectionRanges        []*RangeId    `protobuf:"bytes,4,rep,name=section_ranges,json=sectionRanges,proto3" json:"section_ranges,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RouterNode) Reset()         { *m = RouterNode{} }
func (m *RouterNode) String() string { return proto.CompactTextString(m) }
func (*RouterNode) ProtoMessage()    {}
func (*RouterNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{17}
}
func (m *RouterNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouterNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouterNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouterNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterNode.Merge(m, src)
}
func (m *RouterNode) XXX_Size() int {
	return m.Size()
}
func (m *RouterNode) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterNode.DiscardUnknown(m)
}

var xxx_messageInfo_RouterNode proto.InternalMessageInfo

func (m *RouterNode) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *RouterNode) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *RouterNode) GetNodeAddr() *NodeAddrInfo {
	if m != nil {
		return m.NodeAddr
	}
	return nil
}

func (m *RouterNode) GetSectionRanges() []*RangeId {
	if m != nil {
		return m.SectionRanges
	}
	return nil
}

type TLRouterNode struct {
	Data2                *RouterNode `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TLRouterNode) Reset()         { *m = TLRouterNode{} }
func (m *TLRouterNode) String() string { return proto.CompactTextString(m) }
func (*TLRouterNode) ProtoMessage()    {}
func (*TLRouterNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{18}
}
func (m *TLRouterNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRouterNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRouterNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRouterNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRouterNode.Merge(m, src)
}
func (m *TLRouterNode) XXX_Size() int {
	return m.Size()
}
func (m *TLRouterNode) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRouterNode.DiscardUnknown(m)
}

var xxx_messageInfo_TLRouterNode proto.InternalMessageInfo

func (m *TLRouterNode) GetData2() *RouterNode {
	if m != nil {
		return m.Data2
	}
	return nil
}

// Sequence <--
//  + TL_sequence
//
type Sequence struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	Seq                  int64         `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	Router               *Router       `protobuf:"bytes,4,opt,name=router,proto3" json:"router,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Sequence) Reset()         { *m = Sequence{} }
func (m *Sequence) String() string { return proto.CompactTextString(m) }
func (*Sequence) ProtoMessage()    {}
func (*Sequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{19}
}
func (m *Sequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sequence.Merge(m, src)
}
func (m *Sequence) XXX_Size() int {
	return m.Size()
}
func (m *Sequence) XXX_DiscardUnknown() {
	xxx_messageInfo_Sequence.DiscardUnknown(m)
}

var xxx_messageInfo_Sequence proto.InternalMessageInfo

func (m *Sequence) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *Sequence) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *Sequence) GetSeq() int64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Sequence) GetRouter() *Router {
	if m != nil {
		return m.Router
	}
	return nil
}

type TLSequence struct {
	Data2                *Sequence `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TLSequence) Reset()         { *m = TLSequence{} }
func (m *TLSequence) String() string { return proto.CompactTextString(m) }
func (*TLSequence) ProtoMessage()    {}
func (*TLSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{20}
}
func (m *TLSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSequence.Merge(m, src)
}
func (m *TLSequence) XXX_Size() int {
	return m.Size()
}
func (m *TLSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSequence.DiscardUnknown(m)
}

var xxx_messageInfo_TLSequence proto.InternalMessageInfo

func (m *TLSequence) GetData2() *Sequence {
	if m != nil {
		return m.Data2
	}
	return nil
}

// SetNodeInfo <--
//  + TL_setNodeInfo
//
type SetNodeInfo struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	SetId                *RangeId      `protobuf:"bytes,3,opt,name=set_id,json=setId,proto3" json:"set_id,omitempty"`
	NodeAddr             *NodeAddrInfo `protobuf:"bytes,4,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SetNodeInfo) Reset()         { *m = SetNodeInfo{} }
func (m *SetNodeInfo) String() string { return proto.CompactTextString(m) }
func (*SetNodeInfo) ProtoMessage()    {}
func (*SetNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{21}
}
func (m *SetNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetNodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetNodeInfo.Merge(m, src)
}
func (m *SetNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *SetNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SetNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SetNodeInfo proto.InternalMessageInfo

func (m *SetNodeInfo) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *SetNodeInfo) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *SetNodeInfo) GetSetId() *RangeId {
	if m != nil {
		return m.SetId
	}
	return nil
}

func (m *SetNodeInfo) GetNodeAddr() *NodeAddrInfo {
	if m != nil {
		return m.NodeAddr
	}
	return nil
}

type TLSetNodeInfo struct {
	Data2                *SetNodeInfo `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TLSetNodeInfo) Reset()         { *m = TLSetNodeInfo{} }
func (m *TLSetNodeInfo) String() string { return proto.CompactTextString(m) }
func (*TLSetNodeInfo) ProtoMessage()    {}
func (*TLSetNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{22}
}
func (m *TLSetNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSetNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSetNodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLSetNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSetNodeInfo.Merge(m, src)
}
func (m *TLSetNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLSetNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSetNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLSetNodeInfo proto.InternalMessageInfo

func (m *TLSetNodeInfo) GetData2() *SetNodeInfo {
	if m != nil {
		return m.Data2
	}
	return nil
}

// SetNodeInfoList <--
//  + TL_setNodeInfoList
//
type SetNodeInfoList struct {
	PredicateName        string          `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor   `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	SetId                *RangeId        `protobuf:"bytes,3,opt,name=set_id,json=setId,proto3" json:"set_id,omitempty"`
	NodeAddrs            []*NodeAddrInfo `protobuf:"bytes,4,rep,name=node_addrs,json=nodeAddrs,proto3" json:"node_addrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SetNodeInfoList) Reset()         { *m = SetNodeInfoList{} }
func (m *SetNodeInfoList) String() string { return proto.CompactTextString(m) }
func (*SetNodeInfoList) ProtoMessage()    {}
func (*SetNodeInfoList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{23}
}
func (m *SetNodeInfoList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetNodeInfoList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetNodeInfoList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetNodeInfoList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetNodeInfoList.Merge(m, src)
}
func (m *SetNodeInfoList) XXX_Size() int {
	return m.Size()
}
func (m *SetNodeInfoList) XXX_DiscardUnknown() {
	xxx_messageInfo_SetNodeInfoList.DiscardUnknown(m)
}

var xxx_messageInfo_SetNodeInfoList proto.InternalMessageInfo

func (m *SetNodeInfoList) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *SetNodeInfoList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *SetNodeInfoList) GetSetId() *RangeId {
	if m != nil {
		return m.SetId
	}
	return nil
}

func (m *SetNodeInfoList) GetNodeAddrs() []*NodeAddrInfo {
	if m != nil {
		return m.NodeAddrs
	}
	return nil
}

type TLSetNodeInfoList struct {
	Data2                *SetNodeInfoList `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TLSetNodeInfoList) Reset()         { *m = TLSetNodeInfoList{} }
func (m *TLSetNodeInfoList) String() string { return proto.CompactTextString(m) }
func (*TLSetNodeInfoList) ProtoMessage()    {}
func (*TLSetNodeInfoList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{24}
}
func (m *TLSetNodeInfoList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSetNodeInfoList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSetNodeInfoList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLSetNodeInfoList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSetNodeInfoList.Merge(m, src)
}
func (m *TLSetNodeInfoList) XXX_Size() int {
	return m.Size()
}
func (m *TLSetNodeInfoList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSetNodeInfoList.DiscardUnknown(m)
}

var xxx_messageInfo_TLSetNodeInfoList proto.InternalMessageInfo

func (m *TLSetNodeInfoList) GetData2() *SetNodeInfoList {
	if m != nil {
		return m.Data2
	}
	return nil
}

// Void2 <--
//  + TL_void
//
type Void2 struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Void2) Reset()         { *m = Void2{} }
func (m *Void2) String() string { return proto.CompactTextString(m) }
func (*Void2) ProtoMessage()    {}
func (*Void2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{25}
}
func (m *Void2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Void2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Void2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Void2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void2.Merge(m, src)
}
func (m *Void2) XXX_Size() int {
	return m.Size()
}
func (m *Void2) XXX_DiscardUnknown() {
	xxx_messageInfo_Void2.DiscardUnknown(m)
}

var xxx_messageInfo_Void2 proto.InternalMessageInfo

func (m *Void2) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *Void2) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

type TLVoid struct {
	Data2                *Void2   `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLVoid) Reset()         { *m = TLVoid{} }
func (m *TLVoid) String() string { return proto.CompactTextString(m) }
func (*TLVoid) ProtoMessage()    {}
func (*TLVoid) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{26}
}
func (m *TLVoid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLVoid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLVoid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLVoid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLVoid.Merge(m, src)
}
func (m *TLVoid) XXX_Size() int {
	return m.Size()
}
func (m *TLVoid) XXX_DiscardUnknown() {
	xxx_messageInfo_TLVoid.DiscardUnknown(m)
}

var xxx_messageInfo_TLVoid proto.InternalMessageInfo

func (m *TLVoid) GetData2() *Void2 {
	if m != nil {
		return m.Data2
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLAllocFetchNextSequence struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	Id                   int32         `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	Version              int32         `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAllocFetchNextSequence) Reset()         { *m = TLAllocFetchNextSequence{} }
func (m *TLAllocFetchNextSequence) String() string { return proto.CompactTextString(m) }
func (*TLAllocFetchNextSequence) ProtoMessage()    {}
func (*TLAllocFetchNextSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{27}
}
func (m *TLAllocFetchNextSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAllocFetchNextSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAllocFetchNextSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAllocFetchNextSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAllocFetchNextSequence.Merge(m, src)
}
func (m *TLAllocFetchNextSequence) XXX_Size() int {
	return m.Size()
}
func (m *TLAllocFetchNextSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAllocFetchNextSequence.DiscardUnknown(m)
}

var xxx_messageInfo_TLAllocFetchNextSequence proto.InternalMessageInfo

func (m *TLAllocFetchNextSequence) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAllocFetchNextSequence) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TLAllocFetchNextSequence) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAllocGetCurrentSequence struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	Id                   int32         `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	Version              int32         `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAllocGetCurrentSequence) Reset()         { *m = TLAllocGetCurrentSequence{} }
func (m *TLAllocGetCurrentSequence) String() string { return proto.CompactTextString(m) }
func (*TLAllocGetCurrentSequence) ProtoMessage()    {}
func (*TLAllocGetCurrentSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{28}
}
func (m *TLAllocGetCurrentSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAllocGetCurrentSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAllocGetCurrentSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAllocGetCurrentSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAllocGetCurrentSequence.Merge(m, src)
}
func (m *TLAllocGetCurrentSequence) XXX_Size() int {
	return m.Size()
}
func (m *TLAllocGetCurrentSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAllocGetCurrentSequence.DiscardUnknown(m)
}

var xxx_messageInfo_TLAllocGetCurrentSequence proto.InternalMessageInfo

func (m *TLAllocGetCurrentSequence) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAllocGetCurrentSequence) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TLAllocGetCurrentSequence) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLStoreLoadMaxSeqsData struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLStoreLoadMaxSeqsData) Reset()         { *m = TLStoreLoadMaxSeqsData{} }
func (m *TLStoreLoadMaxSeqsData) String() string { return proto.CompactTextString(m) }
func (*TLStoreLoadMaxSeqsData) ProtoMessage()    {}
func (*TLStoreLoadMaxSeqsData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{29}
}
func (m *TLStoreLoadMaxSeqsData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLStoreLoadMaxSeqsData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLStoreLoadMaxSeqsData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLStoreLoadMaxSeqsData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLStoreLoadMaxSeqsData.Merge(m, src)
}
func (m *TLStoreLoadMaxSeqsData) XXX_Size() int {
	return m.Size()
}
func (m *TLStoreLoadMaxSeqsData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLStoreLoadMaxSeqsData.DiscardUnknown(m)
}

var xxx_messageInfo_TLStoreLoadMaxSeqsData proto.InternalMessageInfo

func (m *TLStoreLoadMaxSeqsData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

//--------------------------------------------------------------------------------------------
type TLStoreSaveMaxSeq struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	Id                   int32         `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	MaxSeq               int64         `protobuf:"varint,4,opt,name=max_seq,json=maxSeq,proto3" json:"max_seq,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLStoreSaveMaxSeq) Reset()         { *m = TLStoreSaveMaxSeq{} }
func (m *TLStoreSaveMaxSeq) String() string { return proto.CompactTextString(m) }
func (*TLStoreSaveMaxSeq) ProtoMessage()    {}
func (*TLStoreSaveMaxSeq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{30}
}
func (m *TLStoreSaveMaxSeq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLStoreSaveMaxSeq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLStoreSaveMaxSeq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLStoreSaveMaxSeq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLStoreSaveMaxSeq.Merge(m, src)
}
func (m *TLStoreSaveMaxSeq) XXX_Size() int {
	return m.Size()
}
func (m *TLStoreSaveMaxSeq) XXX_DiscardUnknown() {
	xxx_messageInfo_TLStoreSaveMaxSeq.DiscardUnknown(m)
}

var xxx_messageInfo_TLStoreSaveMaxSeq proto.InternalMessageInfo

func (m *TLStoreSaveMaxSeq) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLStoreSaveMaxSeq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TLStoreSaveMaxSeq) GetMaxSeq() int64 {
	if m != nil {
		return m.MaxSeq
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLStoreLoadRouteTable struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLStoreLoadRouteTable) Reset()         { *m = TLStoreLoadRouteTable{} }
func (m *TLStoreLoadRouteTable) String() string { return proto.CompactTextString(m) }
func (*TLStoreLoadRouteTable) ProtoMessage()    {}
func (*TLStoreLoadRouteTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{31}
}
func (m *TLStoreLoadRouteTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLStoreLoadRouteTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLStoreLoadRouteTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLStoreLoadRouteTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLStoreLoadRouteTable.Merge(m, src)
}
func (m *TLStoreLoadRouteTable) XXX_Size() int {
	return m.Size()
}
func (m *TLStoreLoadRouteTable) XXX_DiscardUnknown() {
	xxx_messageInfo_TLStoreLoadRouteTable.DiscardUnknown(m)
}

var xxx_messageInfo_TLStoreLoadRouteTable proto.InternalMessageInfo

func (m *TLStoreLoadRouteTable) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

//--------------------------------------------------------------------------------------------
type TLStoreSaveRouteTable struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	Router               *Router       `protobuf:"bytes,3,opt,name=router,proto3" json:"router,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLStoreSaveRouteTable) Reset()         { *m = TLStoreSaveRouteTable{} }
func (m *TLStoreSaveRouteTable) String() string { return proto.CompactTextString(m) }
func (*TLStoreSaveRouteTable) ProtoMessage()    {}
func (*TLStoreSaveRouteTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{32}
}
func (m *TLStoreSaveRouteTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLStoreSaveRouteTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLStoreSaveRouteTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLStoreSaveRouteTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLStoreSaveRouteTable.Merge(m, src)
}
func (m *TLStoreSaveRouteTable) XXX_Size() int {
	return m.Size()
}
func (m *TLStoreSaveRouteTable) XXX_DiscardUnknown() {
	xxx_messageInfo_TLStoreSaveRouteTable.DiscardUnknown(m)
}

var xxx_messageInfo_TLStoreSaveRouteTable proto.InternalMessageInfo

func (m *TLStoreSaveRouteTable) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLStoreSaveRouteTable) GetRouter() *Router {
	if m != nil {
		return m.Router
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediateRegisterAllocSvr struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	NodeAddr             *NodeAddrInfo `protobuf:"bytes,3,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediateRegisterAllocSvr) Reset()         { *m = TLMediateRegisterAllocSvr{} }
func (m *TLMediateRegisterAllocSvr) String() string { return proto.CompactTextString(m) }
func (*TLMediateRegisterAllocSvr) ProtoMessage()    {}
func (*TLMediateRegisterAllocSvr) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{33}
}
func (m *TLMediateRegisterAllocSvr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediateRegisterAllocSvr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediateRegisterAllocSvr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediateRegisterAllocSvr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediateRegisterAllocSvr.Merge(m, src)
}
func (m *TLMediateRegisterAllocSvr) XXX_Size() int {
	return m.Size()
}
func (m *TLMediateRegisterAllocSvr) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediateRegisterAllocSvr.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediateRegisterAllocSvr proto.InternalMessageInfo

func (m *TLMediateRegisterAllocSvr) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediateRegisterAllocSvr) GetNodeAddr() *NodeAddrInfo {
	if m != nil {
		return m.NodeAddr
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediateUnRegisterAllocSvr struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=seqsvr.TLConstructor" json:"constructor,omitempty"`
	NodeAddr             *NodeAddrInfo `protobuf:"bytes,3,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediateUnRegisterAllocSvr) Reset()         { *m = TLMediateUnRegisterAllocSvr{} }
func (m *TLMediateUnRegisterAllocSvr) String() string { return proto.CompactTextString(m) }
func (*TLMediateUnRegisterAllocSvr) ProtoMessage()    {}
func (*TLMediateUnRegisterAllocSvr) Descriptor() ([]byte, []int) {
	return fileDescriptor_f78b45caa22e8ff7, []int{34}
}
func (m *TLMediateUnRegisterAllocSvr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediateUnRegisterAllocSvr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediateUnRegisterAllocSvr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediateUnRegisterAllocSvr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediateUnRegisterAllocSvr.Merge(m, src)
}
func (m *TLMediateUnRegisterAllocSvr) XXX_Size() int {
	return m.Size()
}
func (m *TLMediateUnRegisterAllocSvr) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediateUnRegisterAllocSvr.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediateUnRegisterAllocSvr proto.InternalMessageInfo

func (m *TLMediateUnRegisterAllocSvr) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediateUnRegisterAllocSvr) GetNodeAddr() *NodeAddrInfo {
	if m != nil {
		return m.NodeAddr
	}
	return nil
}

func init() {
	proto.RegisterEnum("seqsvr.TLConstructor", TLConstructor_name, TLConstructor_value)
	proto.RegisterType((*Bool2)(nil), "seqsvr.Bool2")
	proto.RegisterType((*TLBoolFalse2)(nil), "seqsvr.TL_boolFalse2")
	proto.RegisterType((*TLBoolTrue2)(nil), "seqsvr.TL_boolTrue2")
	proto.RegisterType((*Int32V)(nil), "seqsvr.Int32V")
	proto.RegisterType((*TLInt32V)(nil), "seqsvr.TL_int32V")
	proto.RegisterType((*Int64V)(nil), "seqsvr.Int64V")
	proto.RegisterType((*TLInt64V)(nil), "seqsvr.TL_int64V")
	proto.RegisterType((*MaxSeqsData)(nil), "seqsvr.MaxSeqsData")
	proto.RegisterType((*TLMaxSeqsData)(nil), "seqsvr.TL_maxSeqsData")
	proto.RegisterType((*NodeAddrInfo)(nil), "seqsvr.NodeAddrInfo")
	proto.RegisterType((*TLNodeAddrInfo)(nil), "seqsvr.TL_nodeAddrInfo")
	proto.RegisterType((*PerSetRouterTable)(nil), "seqsvr.PerSetRouterTable")
	proto.RegisterType((*TLPerSetRouterTable)(nil), "seqsvr.TL_perSetRouterTable")
	proto.RegisterType((*RangeId)(nil), "seqsvr.RangeId")
	proto.RegisterType((*TLRangeId)(nil), "seqsvr.TL_rangeId")
	proto.RegisterType((*Router)(nil), "seqsvr.Router")
	proto.RegisterType((*TLRouter)(nil), "seqsvr.TL_router")
	proto.RegisterType((*RouterNode)(nil), "seqsvr.RouterNode")
	proto.RegisterType((*TLRouterNode)(nil), "seqsvr.TL_routerNode")
	proto.RegisterType((*Sequence)(nil), "seqsvr.Sequence")
	proto.RegisterType((*TLSequence)(nil), "seqsvr.TL_sequence")
	proto.RegisterType((*SetNodeInfo)(nil), "seqsvr.SetNodeInfo")
	proto.RegisterType((*TLSetNodeInfo)(nil), "seqsvr.TL_setNodeInfo")
	proto.RegisterType((*SetNodeInfoList)(nil), "seqsvr.SetNodeInfoList")
	proto.RegisterType((*TLSetNodeInfoList)(nil), "seqsvr.TL_setNodeInfoList")
	proto.RegisterType((*Void2)(nil), "seqsvr.Void2")
	proto.RegisterType((*TLVoid)(nil), "seqsvr.TL_void")
	proto.RegisterType((*TLAllocFetchNextSequence)(nil), "seqsvr.TL_alloc_fetchNextSequence")
	proto.RegisterType((*TLAllocGetCurrentSequence)(nil), "seqsvr.TL_alloc_getCurrentSequence")
	proto.RegisterType((*TLStoreLoadMaxSeqsData)(nil), "seqsvr.TL_store_loadMaxSeqsData")
	proto.RegisterType((*TLStoreSaveMaxSeq)(nil), "seqsvr.TL_store_saveMaxSeq")
	proto.RegisterType((*TLStoreLoadRouteTable)(nil), "seqsvr.TL_store_loadRouteTable")
	proto.RegisterType((*TLStoreSaveRouteTable)(nil), "seqsvr.TL_store_saveRouteTable")
	proto.RegisterType((*TLMediateRegisterAllocSvr)(nil), "seqsvr.TL_mediate_registerAllocSvr")
	proto.RegisterType((*TLMediateUnRegisterAllocSvr)(nil), "seqsvr.TL_mediate_unRegisterAllocSvr")
}

func init() { proto.RegisterFile("seqsvr.tl.proto", fileDescriptor_f78b45caa22e8ff7) }

var fileDescriptor_f78b45caa22e8ff7 = []byte{
	// 1503 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x5d, 0x6c, 0x14, 0xd5,
	0x17, 0xdf, 0xe9, 0x7e, 0xb4, 0x3d, 0xdb, 0x6e, 0x2f, 0x97, 0x96, 0x6e, 0x97, 0x7f, 0x97, 0x66,
	0xf8, 0xda, 0x3f, 0x86, 0x36, 0x4c, 0x6b, 0x0d, 0x31, 0x3e, 0xc0, 0x1a, 0xb5, 0x71, 0xa9, 0x75,
	0x76, 0xc4, 0xc4, 0x97, 0xc9, 0x74, 0xe7, 0xb2, 0x4c, 0xb2, 0xbb, 0xd3, 0xce, 0xcc, 0xae, 0x84,
	0x98, 0xc8, 0x83, 0x26, 0x18, 0x89, 0x44, 0x30, 0x62, 0x0c, 0x9a, 0x80, 0x24, 0x6a, 0xf4, 0x41,
	0xa4, 0xc6, 0xf8, 0xa4, 0x24, 0x9a, 0xf0, 0xe0, 0x17, 0x3e, 0x48, 0x62, 0xa2, 0x51, 0x34, 0xa2,
	0x10, 0xc0, 0xc4, 0xa8, 0x88, 0x4a, 0xcd, 0xcc, 0x9d, 0xd9, 0x9d, 0xe9, 0xcc, 0x12, 0x20, 0x6c,
	0xe5, 0x6d, 0xee, 0x3d, 0xe7, 0x9e, 0xfb, 0xfb, 0x9d, 0x7b, 0xef, 0xef, 0xdc, 0x3b, 0xd0, 0xa3,
	0x93, 0x59, 0xbd, 0xa6, 0x0d, 0x1b, 0xa5, 0xe1, 0x19, 0x4d, 0x35, 0x54, 0x1c, 0xa3, 0x1d, 0xa9,
	0xf5, 0x45, 0xc5, 0xd8, 0x5e, 0x9d, 0x1e, 0x2e, 0xa8, 0xe5, 0x91, 0xa2, 0x5a, 0x54, 0x47, 0x2c,
	0xf3, 0x74, 0x75, 0x9b, 0xd5, 0xb2, 0x1a, 0xd6, 0x17, 0x1d, 0xc6, 0x16, 0x21, 0xba, 0x59, 0x55,
	0x4b, 0x1c, 0x5e, 0x0d, 0x89, 0x19, 0x8d, 0xc8, 0x4a, 0x41, 0x32, 0x88, 0x58, 0x91, 0xca, 0x24,
	0xc9, 0x0c, 0x31, 0x99, 0x4e, 0xbe, 0xbb, 0xde, 0x3b, 0x29, 0x95, 0x09, 0xbe, 0x03, 0xe2, 0x05,
	0xb5, 0xa2, 0x1b, 0x5a, 0xb5, 0x60, 0xa8, 0x5a, 0xb2, 0x6d, 0x88, 0xc9, 0x24, 0xb8, 0xbe, 0x61,
	0x1b, 0x8d, 0x90, 0xcb, 0x36, 0x8c, 0xbc, 0xdb, 0x93, 0x1d, 0x83, 0x6e, 0x21, 0x27, 0x4e, 0xab,
	0x6a, 0xe9, 0x1e, 0xa9, 0xa4, 0x13, 0x0e, 0xaf, 0x84, 0xa8, 0x2c, 0x19, 0x12, 0x67, 0xcd, 0x13,
	0xe7, 0xba, 0x9d, 0x18, 0x16, 0x1c, 0x9e, 0xda, 0xd8, 0x51, 0xe8, 0xb2, 0x47, 0x09, 0x5a, 0xf5,
	0x5a, 0x07, 0xd5, 0x20, 0x36, 0x51, 0x31, 0x46, 0xb9, 0xad, 0xad, 0x26, 0x85, 0xbb, 0x80, 0xa9,
	0x25, 0xc3, 0x43, 0x4c, 0x26, 0xca, 0x33, 0x35, 0x76, 0x03, 0x74, 0x0a, 0x39, 0x51, 0xa1, 0x53,
	0xaf, 0xf2, 0x22, 0x4d, 0x38, 0xd1, 0x28, 0x32, 0x2f, 0xd4, 0xf1, 0xb1, 0x45, 0x84, 0x1a, 0xf6,
	0x40, 0x35, 0xa7, 0xbe, 0x0a, 0xd4, 0xf1, 0xb1, 0x3a, 0xd4, 0xb7, 0x18, 0x88, 0x6f, 0x91, 0x76,
	0xe4, 0xc9, 0xac, 0x7e, 0xb7, 0x64, 0x48, 0x2d, 0x07, 0xbc, 0x06, 0x62, 0x3a, 0x31, 0x44, 0x45,
	0xb6, 0x50, 0xc7, 0xb9, 0x1e, 0x67, 0x0c, 0x2f, 0x55, 0x8a, 0x64, 0x42, 0xe6, 0xa3, 0x3a, 0x31,
	0x26, 0x64, 0x3c, 0x00, 0x1d, 0x65, 0x69, 0x87, 0x68, 0x1a, 0x93, 0x91, 0xa1, 0x70, 0x26, 0xcc,
	0xb7, 0x97, 0x29, 0x4c, 0xf6, 0x4e, 0x48, 0x08, 0x39, 0xb1, 0xec, 0x02, 0xfd, 0x7f, 0x2f, 0xd5,
	0xa5, 0x4e, 0x4c, 0x17, 0x31, 0x87, 0xef, 0x3e, 0x06, 0xba, 0x26, 0x55, 0x99, 0x6c, 0x92, 0x65,
	0x6d, 0xa2, 0xb2, 0x4d, 0x6d, 0x39, 0xe1, 0x04, 0xb4, 0x29, 0x33, 0x16, 0xd9, 0x4e, 0xbe, 0x4d,
	0x99, 0xc1, 0x18, 0x22, 0x33, 0xaa, 0x66, 0x24, 0x23, 0xd6, 0xfe, 0xb2, 0xbe, 0xd9, 0xbb, 0xa0,
	0x47, 0xc8, 0x89, 0x15, 0x37, 0xac, 0x75, 0x5e, 0x4a, 0xbd, 0xce, 0x4c, 0x6e, 0xec, 0x0e, 0xa7,
	0x8f, 0x19, 0x58, 0x32, 0x45, 0xb4, 0x3c, 0x31, 0x78, 0xb5, 0x6a, 0x10, 0x4d, 0x90, 0xa6, 0x4b,
	0xe4, 0x96, 0x59, 0xc9, 0x11, 0xe8, 0x34, 0x99, 0x89, 0x25, 0x45, 0x37, 0xac, 0xa5, 0x8c, 0x73,
	0xb8, 0xee, 0x6a, 0xe1, 0x35, 0x39, 0xf1, 0x1d, 0xa6, 0x53, 0x4e, 0xd1, 0x0d, 0xf6, 0x5e, 0xe8,
	0x15, 0x72, 0xe2, 0x8c, 0x8f, 0xd0, 0x88, 0x37, 0x25, 0x03, 0x4e, 0x10, 0x1f, 0x75, 0x27, 0x2f,
	0x2f, 0x32, 0xd0, 0x6e, 0x83, 0x69, 0x79, 0x36, 0x06, 0xa0, 0x43, 0x91, 0xc5, 0x69, 0x52, 0x54,
	0x2a, 0xb6, 0x74, 0xb4, 0x2b, 0xf2, 0x66, 0xb3, 0x89, 0x7b, 0x21, 0xaa, 0x2b, 0x3b, 0x09, 0x67,
	0x2f, 0x39, 0x6d, 0xb0, 0xa3, 0x00, 0x42, 0x4e, 0xd4, 0xea, 0xf0, 0x3c, 0xdc, 0xfc, 0xb9, 0xa4,
	0x8c, 0x8e, 0x31, 0x10, 0xa3, 0x44, 0x5b, 0x4e, 0x28, 0x09, 0xed, 0x35, 0xa2, 0xe9, 0x8a, 0x5a,
	0xe7, 0x63, 0x37, 0xaf, 0x7f, 0x41, 0xa9, 0x2c, 0x69, 0x14, 0x77, 0x33, 0x59, 0xa2, 0x23, 0x1d,
	0xa2, 0xa7, 0x18, 0x80, 0x46, 0xac, 0x96, 0x93, 0xdd, 0x60, 0x53, 0x92, 0x64, 0x59, 0xb3, 0xb7,
	0x73, 0xf0, 0x89, 0xeb, 0x70, 0x0e, 0x29, 0x1e, 0x87, 0x84, 0x4e, 0x0a, 0x86, 0xa2, 0x56, 0xe8,
	0x22, 0xea, 0x76, 0x2a, 0x7c, 0x4b, 0xd7, 0x6d, 0xbb, 0x59, 0x6d, 0x9d, 0xdd, 0x68, 0x55, 0x4c,
	0xad, 0xc1, 0x2d, 0xe3, 0x4d, 0x48, 0x50, 0x2a, 0xed, 0xa4, 0x1c, 0x61, 0xa0, 0x23, 0x4f, 0x66,
	0xab, 0xa4, 0x52, 0x68, 0x7d, 0x4a, 0x10, 0x84, 0x75, 0x32, 0x6b, 0xd7, 0x16, 0xf3, 0xd3, 0x3c,
	0xf0, 0x14, 0xb6, 0xb5, 0x91, 0xfd, 0x4b, 0x67, 0x5b, 0xd9, 0xdb, 0x21, 0x2e, 0xe4, 0x4c, 0xe5,
	0xa6, 0x40, 0xd7, 0x78, 0xf9, 0x21, 0x67, 0x94, 0xc3, 0xc4, 0x61, 0x77, 0x82, 0x81, 0x78, 0x9e,
	0x18, 0x26, 0xe1, 0x45, 0x11, 0xe6, 0x6b, 0xd5, 0x2f, 0xcf, 0xde, 0x88, 0x5c, 0xcb, 0xde, 0xb0,
	0x2b, 0x94, 0xee, 0x22, 0xd3, 0xac, 0x42, 0xb9, 0x08, 0x3b, 0x79, 0xf8, 0x94, 0x81, 0x1e, 0x57,
	0xb7, 0x79, 0x82, 0x6e, 0x99, 0x5c, 0x8c, 0x02, 0xd4, 0x73, 0xe1, 0x6c, 0xf8, 0xe0, 0x64, 0x74,
	0x3a, 0xc9, 0xd0, 0xd9, 0x2c, 0x60, 0x6f, 0x36, 0x2c, 0x4a, 0xeb, 0xbd, 0x19, 0xe9, 0x0f, 0xc8,
	0x88, 0xe9, 0xe7, 0x64, 0xa5, 0x08, 0xd1, 0xad, 0xaa, 0x22, 0xb7, 0xfe, 0x46, 0x3b, 0x0c, 0xed,
	0x42, 0x4e, 0xac, 0xa9, 0x8a, 0xdc, 0xf4, 0x5a, 0x6a, 0x01, 0x71, 0x80, 0x3d, 0x0e, 0x29, 0x21,
	0x27, 0x4a, 0xa5, 0x92, 0x5a, 0x10, 0xb7, 0x11, 0xa3, 0xb0, 0x7d, 0x92, 0xec, 0x30, 0xea, 0xa7,
	0x74, 0x01, 0x0c, 0xe6, 0xba, 0xae, 0x0d, 0xb2, 0xad, 0xbc, 0x6d, 0x8a, 0xec, 0x96, 0xe3, 0x88,
	0x47, 0x8e, 0xd9, 0x5d, 0x0c, 0x2c, 0xaf, 0x23, 0x28, 0x12, 0x23, 0x5b, 0xd5, 0x34, 0x52, 0x59,
	0x54, 0x08, 0x79, 0x48, 0x9a, 0x2b, 0x6c, 0xa8, 0x1a, 0x11, 0x4b, 0xaa, 0x24, 0xbb, 0x2f, 0x94,
	0x37, 0x3a, 0x3d, 0xfb, 0x28, 0x2c, 0xad, 0x07, 0xd5, 0xa5, 0x1a, 0xa1, 0x41, 0x6f, 0x1e, 0x9d,
	0x7e, 0x68, 0xb7, 0x6f, 0x98, 0x16, 0x9d, 0x30, 0x1f, 0xa3, 0x57, 0x4a, 0x96, 0x87, 0x7e, 0x0f,
	0x1b, 0x4b, 0xde, 0xe8, 0x15, 0xe4, 0x86, 0xc9, 0xec, 0x74, 0xc5, 0x34, 0xc9, 0xdc, 0x84, 0x98,
	0x2e, 0x3d, 0x0e, 0x5f, 0x55, 0x8f, 0x9f, 0xa2, 0x1b, 0xa4, 0x4c, 0x64, 0xc5, 0x3c, 0x33, 0x1a,
	0x29, 0x2a, 0xba, 0x41, 0xb4, 0x4d, 0xe6, 0x86, 0xc9, 0xd7, 0xb4, 0x1b, 0x07, 0x70, 0xfd, 0x55,
	0x93, 0x7d, 0x9a, 0x81, 0x41, 0x17, 0x96, 0x6a, 0x85, 0xff, 0x0f, 0xd1, 0xac, 0xbb, 0x18, 0x35,
	0x8b, 0xb1, 0x2b, 0x22, 0x5e, 0x02, 0xdd, 0x59, 0x3e, 0x3b, 0xca, 0x89, 0x0f, 0x4d, 0xde, 0x3f,
	0xf9, 0xc0, 0xc3, 0x93, 0x28, 0x84, 0x07, 0xa0, 0x8b, 0x76, 0xd1, 0x27, 0x20, 0xfa, 0xf1, 0xcc,
	0x57, 0x97, 0xff, 0x9e, 0x9f, 0x9f, 0x9f, 0x67, 0x70, 0xaf, 0xcb, 0x34, 0x3e, 0xb6, 0x15, 0x7d,
	0x7d, 0xe1, 0xf0, 0x4f, 0x51, 0x3c, 0x08, 0x88, 0xf6, 0x36, 0x9e, 0xc5, 0xe8, 0x83, 0x73, 0xbb,
	0x0e, 0x5e, 0xa6, 0x83, 0xfe, 0x07, 0x3d, 0x0d, 0xb3, 0xf5, 0xfe, 0x45, 0x5f, 0x7e, 0xf1, 0xd1,
	0xa1, 0x2b, 0xd4, 0x8a, 0x01, 0xa8, 0xd5, 0x54, 0x20, 0x74, 0xea, 0xa5, 0x37, 0x9f, 0x0f, 0xe3,
	0x14, 0x60, 0xda, 0xe7, 0x7e, 0x21, 0xa0, 0x4f, 0x0e, 0x3e, 0xfb, 0x67, 0x04, 0xf7, 0x39, 0x80,
	0xed, 0x9b, 0x24, 0xfa, 0xec, 0xc0, 0xd1, 0x33, 0x6d, 0x0d, 0x0c, 0x8d, 0x8b, 0x06, 0xfa, 0xe6,
	0xfd, 0xd7, 0x9f, 0xb3, 0x67, 0xa9, 0x73, 0xa2, 0x66, 0x74, 0xe9, 0xb7, 0xb3, 0x7b, 0xff, 0xa2,
	0xa6, 0x34, 0x2c, 0xa1, 0x26, 0x97, 0x60, 0xa3, 0x4b, 0xcf, 0x9c, 0xfa, 0xf0, 0x92, 0x03, 0xbf,
	0xcf, 0x67, 0x37, 0x85, 0x1a, 0xed, 0xff, 0xe3, 0xf0, 0x63, 0x78, 0x15, 0xf4, 0x53, 0xab, 0xef,
	0xfa, 0x8e, 0xce, 0xff, 0x7e, 0xe4, 0xb5, 0x7f, 0x68, 0x8c, 0x65, 0x90, 0x70, 0x62, 0x50, 0x91,
	0x42, 0x07, 0xce, 0x9e, 0x3f, 0x16, 0xc3, 0x03, 0xce, 0xdc, 0xae, 0xc7, 0x1d, 0x7a, 0xf7, 0xe7,
	0x5d, 0x17, 0x62, 0x78, 0x1d, 0x0c, 0x52, 0x53, 0x13, 0xa5, 0x45, 0x2f, 0xef, 0x3b, 0x74, 0xce,
	0x0e, 0xbf, 0x06, 0xd2, 0x6e, 0x5f, 0xbf, 0x26, 0xa2, 0xa3, 0x27, 0x5f, 0xd8, 0x1f, 0xc5, 0x19,
	0x58, 0x6e, 0xc3, 0x08, 0x52, 0x2e, 0xb4, 0xe7, 0xf8, 0x13, 0x57, 0xec, 0x88, 0x83, 0xb0, 0xcc,
	0xed, 0xd9, 0x90, 0x23, 0xf4, 0xe4, 0xaf, 0xc7, 0xd7, 0xe3, 0xb5, 0x90, 0x5a, 0x18, 0xa8, 0x71,
	0xc0, 0xd1, 0xde, 0x37, 0x76, 0x9f, 0xb1, 0x37, 0x0c, 0xeb, 0x75, 0xf4, 0x2a, 0x01, 0x9a, 0x3b,
	0xf9, 0xea, 0xc5, 0x30, 0xbe, 0xcd, 0x41, 0xdf, 0xec, 0xc0, 0xa2, 0xb9, 0x1f, 0xae, 0xbc, 0x63,
	0x6f, 0xa6, 0x0c, 0x0c, 0x79, 0x9d, 0xfd, 0x27, 0x0a, 0xbd, 0x77, 0xf6, 0xfb, 0x3d, 0xb1, 0x54,
	0x64, 0xf7, 0x2b, 0xe9, 0x10, 0xf7, 0x36, 0x03, 0x1d, 0xfc, 0x54, 0xd6, 0xb2, 0xe1, 0x07, 0xa1,
	0xbf, 0x59, 0xdd, 0x62, 0x1b, 0x07, 0xae, 0x59, 0xc6, 0x53, 0xbe, 0x9b, 0x1c, 0x1b, 0xc2, 0x79,
	0x48, 0x36, 0x2d, 0x44, 0x2b, 0x7d, 0x31, 0xfd, 0x4e, 0x41, 0x41, 0xb9, 0x39, 0xf3, 0x31, 0x30,
	0x95, 0xdd, 0x42, 0x29, 0xe2, 0x29, 0x48, 0x36, 0xd5, 0x32, 0xf7, 0x1c, 0xcd, 0x9c, 0x52, 0xde,
	0xff, 0x4b, 0x6c, 0x08, 0x0b, 0x90, 0xba, 0x8a, 0x22, 0xad, 0x0e, 0x88, 0xe9, 0x77, 0xf3, 0x45,
	0xe5, 0xe6, 0xda, 0xac, 0x5c, 0xe7, 0xcd, 0xa5, 0xc6, 0x53, 0xd0, 0x17, 0x5c, 0x1f, 0x87, 0x5c,
	0xd1, 0x03, 0x3d, 0x52, 0x41, 0xbf, 0x33, 0xd8, 0x10, 0xde, 0x04, 0xc8, 0x57, 0x1c, 0x97, 0xfb,
	0x82, 0x35, 0x8c, 0xa9, 0x05, 0x7f, 0x80, 0xd8, 0x10, 0x9e, 0x80, 0xde, 0xc0, 0x32, 0xb7, 0x22,
	0x10, 0x53, 0xc3, 0x21, 0xb5, 0xa0, 0xd4, 0xb0, 0x21, 0x7c, 0x9f, 0x13, 0x6a, 0x41, 0x75, 0x5b,
	0x11, 0x88, 0xc8, 0x15, 0x6a, 0x61, 0xda, 0x36, 0x6f, 0xfc, 0xe5, 0xbb, 0x34, 0x73, 0xe2, 0x74,
	0x9a, 0xf9, 0xfc, 0x74, 0x9a, 0xf9, 0xf6, 0x74, 0x9a, 0x79, 0x64, 0xad, 0xeb, 0xe7, 0xa7, 0x41,
	0xa4, 0x72, 0x51, 0x93, 0xca, 0x23, 0x74, 0x14, 0xfd, 0x0f, 0x6a, 0x37, 0xa6, 0x63, 0x56, 0x6b,
	0xf4, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xeb, 0x28, 0x5c, 0xad, 0x47, 0x15, 0x00, 0x00,
}

func (this *Bool2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&seqsvr.Bool2{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLBoolFalse2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLBoolFalse2{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLBoolTrue2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLBoolTrue2{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Int32V) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&seqsvr.Int32V{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "V: "+fmt.Sprintf("%#v", this.V)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInt32V) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLInt32V{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Int64V) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&seqsvr.Int64V{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "V: "+fmt.Sprintf("%#v", this.V)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInt64V) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLInt64V{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MaxSeqsData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&seqsvr.MaxSeqsData{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.SetId != nil {
		s = append(s, "SetId: "+fmt.Sprintf("%#v", this.SetId)+",\n")
	}
	s = append(s, "MaxSeqs: "+fmt.Sprintf("%#v", this.MaxSeqs)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMaxSeqsData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLMaxSeqsData{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeAddrInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&seqsvr.NodeAddrInfo{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLNodeAddrInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLNodeAddrInfo{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PerSetRouterTable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&seqsvr.PerSetRouterTable{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.SetId != nil {
		s = append(s, "SetId: "+fmt.Sprintf("%#v", this.SetId)+",\n")
	}
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLPerSetRouterTable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLPerSetRouterTable{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RangeId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&seqsvr.RangeId{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "IdBegin: "+fmt.Sprintf("%#v", this.IdBegin)+",\n")
	s = append(s, "Size2: "+fmt.Sprintf("%#v", this.Size2)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLRangeId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLRangeId{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Router) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&seqsvr.Router{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLRouter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLRouter{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouterNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&seqsvr.RouterNode{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.NodeAddr != nil {
		s = append(s, "NodeAddr: "+fmt.Sprintf("%#v", this.NodeAddr)+",\n")
	}
	if this.SectionRanges != nil {
		s = append(s, "SectionRanges: "+fmt.Sprintf("%#v", this.SectionRanges)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLRouterNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLRouterNode{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sequence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&seqsvr.Sequence{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	if this.Router != nil {
		s = append(s, "Router: "+fmt.Sprintf("%#v", this.Router)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSequence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLSequence{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetNodeInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&seqsvr.SetNodeInfo{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.SetId != nil {
		s = append(s, "SetId: "+fmt.Sprintf("%#v", this.SetId)+",\n")
	}
	if this.NodeAddr != nil {
		s = append(s, "NodeAddr: "+fmt.Sprintf("%#v", this.NodeAddr)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSetNodeInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLSetNodeInfo{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetNodeInfoList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&seqsvr.SetNodeInfoList{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.SetId != nil {
		s = append(s, "SetId: "+fmt.Sprintf("%#v", this.SetId)+",\n")
	}
	if this.NodeAddrs != nil {
		s = append(s, "NodeAddrs: "+fmt.Sprintf("%#v", this.NodeAddrs)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSetNodeInfoList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLSetNodeInfoList{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Void2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&seqsvr.Void2{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLVoid) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLVoid{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAllocFetchNextSequence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&seqsvr.TLAllocFetchNextSequence{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAllocGetCurrentSequence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&seqsvr.TLAllocGetCurrentSequence{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLStoreLoadMaxSeqsData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLStoreLoadMaxSeqsData{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLStoreSaveMaxSeq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&seqsvr.TLStoreSaveMaxSeq{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "MaxSeq: "+fmt.Sprintf("%#v", this.MaxSeq)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLStoreLoadRouteTable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&seqsvr.TLStoreLoadRouteTable{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLStoreSaveRouteTable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&seqsvr.TLStoreSaveRouteTable{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.Router != nil {
		s = append(s, "Router: "+fmt.Sprintf("%#v", this.Router)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediateRegisterAllocSvr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&seqsvr.TLMediateRegisterAllocSvr{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.NodeAddr != nil {
		s = append(s, "NodeAddr: "+fmt.Sprintf("%#v", this.NodeAddr)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediateUnRegisterAllocSvr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&seqsvr.TLMediateUnRegisterAllocSvr{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.NodeAddr != nil {
		s = append(s, "NodeAddr: "+fmt.Sprintf("%#v", this.NodeAddr)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSeqsvrTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCAllocClient is the client API for RPCAlloc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCAllocClient interface {
	AllocFetchNextSequence(ctx context.Context, in *TLAllocFetchNextSequence, opts ...grpc.CallOption) (*Sequence, error)
	AllocGetCurrentSequence(ctx context.Context, in *TLAllocGetCurrentSequence, opts ...grpc.CallOption) (*Sequence, error)
}

type rPCAllocClient struct {
	cc *grpc.ClientConn
}

func NewRPCAllocClient(cc *grpc.ClientConn) RPCAllocClient {
	return &rPCAllocClient{cc}
}

func (c *rPCAllocClient) AllocFetchNextSequence(ctx context.Context, in *TLAllocFetchNextSequence, opts ...grpc.CallOption) (*Sequence, error) {
	out := new(Sequence)
	err := c.cc.Invoke(ctx, "/seqsvr.RPCAlloc/alloc_fetchNextSequence", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAllocClient) AllocGetCurrentSequence(ctx context.Context, in *TLAllocGetCurrentSequence, opts ...grpc.CallOption) (*Sequence, error) {
	out := new(Sequence)
	err := c.cc.Invoke(ctx, "/seqsvr.RPCAlloc/alloc_getCurrentSequence", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCAllocServer is the server API for RPCAlloc service.
type RPCAllocServer interface {
	AllocFetchNextSequence(context.Context, *TLAllocFetchNextSequence) (*Sequence, error)
	AllocGetCurrentSequence(context.Context, *TLAllocGetCurrentSequence) (*Sequence, error)
}

// UnimplementedRPCAllocServer can be embedded to have forward compatible implementations.
type UnimplementedRPCAllocServer struct {
}

func (*UnimplementedRPCAllocServer) AllocFetchNextSequence(ctx context.Context, req *TLAllocFetchNextSequence) (*Sequence, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocFetchNextSequence not implemented")
}
func (*UnimplementedRPCAllocServer) AllocGetCurrentSequence(ctx context.Context, req *TLAllocGetCurrentSequence) (*Sequence, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocGetCurrentSequence not implemented")
}

func RegisterRPCAllocServer(s *grpc.Server, srv RPCAllocServer) {
	s.RegisterService(&_RPCAlloc_serviceDesc, srv)
}

func _RPCAlloc_AllocFetchNextSequence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAllocFetchNextSequence)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAllocServer).AllocFetchNextSequence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seqsvr.RPCAlloc/AllocFetchNextSequence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAllocServer).AllocFetchNextSequence(ctx, req.(*TLAllocFetchNextSequence))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAlloc_AllocGetCurrentSequence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAllocGetCurrentSequence)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAllocServer).AllocGetCurrentSequence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seqsvr.RPCAlloc/AllocGetCurrentSequence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAllocServer).AllocGetCurrentSequence(ctx, req.(*TLAllocGetCurrentSequence))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCAlloc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "seqsvr.RPCAlloc",
	HandlerType: (*RPCAllocServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "alloc_fetchNextSequence",
			Handler:    _RPCAlloc_AllocFetchNextSequence_Handler,
		},
		{
			MethodName: "alloc_getCurrentSequence",
			Handler:    _RPCAlloc_AllocGetCurrentSequence_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "seqsvr.tl.proto",
}

// RPCMediateClient is the client API for RPCMediate service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCMediateClient interface {
	MediateRegisterAllocSvr(ctx context.Context, in *TLMediateRegisterAllocSvr, opts ...grpc.CallOption) (*Bool2, error)
	MediateUnRegisterAllocSvr(ctx context.Context, in *TLMediateUnRegisterAllocSvr, opts ...grpc.CallOption) (*Bool2, error)
}

type rPCMediateClient struct {
	cc *grpc.ClientConn
}

func NewRPCMediateClient(cc *grpc.ClientConn) RPCMediateClient {
	return &rPCMediateClient{cc}
}

func (c *rPCMediateClient) MediateRegisterAllocSvr(ctx context.Context, in *TLMediateRegisterAllocSvr, opts ...grpc.CallOption) (*Bool2, error) {
	out := new(Bool2)
	err := c.cc.Invoke(ctx, "/seqsvr.RPCMediate/mediate_registerAllocSvr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediateClient) MediateUnRegisterAllocSvr(ctx context.Context, in *TLMediateUnRegisterAllocSvr, opts ...grpc.CallOption) (*Bool2, error) {
	out := new(Bool2)
	err := c.cc.Invoke(ctx, "/seqsvr.RPCMediate/mediate_unRegisterAllocSvr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCMediateServer is the server API for RPCMediate service.
type RPCMediateServer interface {
	MediateRegisterAllocSvr(context.Context, *TLMediateRegisterAllocSvr) (*Bool2, error)
	MediateUnRegisterAllocSvr(context.Context, *TLMediateUnRegisterAllocSvr) (*Bool2, error)
}

// UnimplementedRPCMediateServer can be embedded to have forward compatible implementations.
type UnimplementedRPCMediateServer struct {
}

func (*UnimplementedRPCMediateServer) MediateRegisterAllocSvr(ctx context.Context, req *TLMediateRegisterAllocSvr) (*Bool2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediateRegisterAllocSvr not implemented")
}
func (*UnimplementedRPCMediateServer) MediateUnRegisterAllocSvr(ctx context.Context, req *TLMediateUnRegisterAllocSvr) (*Bool2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediateUnRegisterAllocSvr not implemented")
}

func RegisterRPCMediateServer(s *grpc.Server, srv RPCMediateServer) {
	s.RegisterService(&_RPCMediate_serviceDesc, srv)
}

func _RPCMediate_MediateRegisterAllocSvr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediateRegisterAllocSvr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediateServer).MediateRegisterAllocSvr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seqsvr.RPCMediate/MediateRegisterAllocSvr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediateServer).MediateRegisterAllocSvr(ctx, req.(*TLMediateRegisterAllocSvr))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMediate_MediateUnRegisterAllocSvr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediateUnRegisterAllocSvr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediateServer).MediateUnRegisterAllocSvr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seqsvr.RPCMediate/MediateUnRegisterAllocSvr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediateServer).MediateUnRegisterAllocSvr(ctx, req.(*TLMediateUnRegisterAllocSvr))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCMediate_serviceDesc = grpc.ServiceDesc{
	ServiceName: "seqsvr.RPCMediate",
	HandlerType: (*RPCMediateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "mediate_registerAllocSvr",
			Handler:    _RPCMediate_MediateRegisterAllocSvr_Handler,
		},
		{
			MethodName: "mediate_unRegisterAllocSvr",
			Handler:    _RPCMediate_MediateUnRegisterAllocSvr_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "seqsvr.tl.proto",
}

// RPCStoreClient is the client API for RPCStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCStoreClient interface {
	StoreLoadMaxSeqsData(ctx context.Context, in *TLStoreLoadMaxSeqsData, opts ...grpc.CallOption) (*MaxSeqsData, error)
	StoreSaveMaxSeq(ctx context.Context, in *TLStoreSaveMaxSeq, opts ...grpc.CallOption) (*Int64V, error)
	StoreLoadRouteTable(ctx context.Context, in *TLStoreLoadRouteTable, opts ...grpc.CallOption) (*Router, error)
	StoreSaveRouteTable(ctx context.Context, in *TLStoreSaveRouteTable, opts ...grpc.CallOption) (*Bool2, error)
}

type rPCStoreClient struct {
	cc *grpc.ClientConn
}

func NewRPCStoreClient(cc *grpc.ClientConn) RPCStoreClient {
	return &rPCStoreClient{cc}
}

func (c *rPCStoreClient) StoreLoadMaxSeqsData(ctx context.Context, in *TLStoreLoadMaxSeqsData, opts ...grpc.CallOption) (*MaxSeqsData, error) {
	out := new(MaxSeqsData)
	err := c.cc.Invoke(ctx, "/seqsvr.RPCStore/store_loadMaxSeqsData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCStoreClient) StoreSaveMaxSeq(ctx context.Context, in *TLStoreSaveMaxSeq, opts ...grpc.CallOption) (*Int64V, error) {
	out := new(Int64V)
	err := c.cc.Invoke(ctx, "/seqsvr.RPCStore/store_saveMaxSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCStoreClient) StoreLoadRouteTable(ctx context.Context, in *TLStoreLoadRouteTable, opts ...grpc.CallOption) (*Router, error) {
	out := new(Router)
	err := c.cc.Invoke(ctx, "/seqsvr.RPCStore/store_loadRouteTable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCStoreClient) StoreSaveRouteTable(ctx context.Context, in *TLStoreSaveRouteTable, opts ...grpc.CallOption) (*Bool2, error) {
	out := new(Bool2)
	err := c.cc.Invoke(ctx, "/seqsvr.RPCStore/store_saveRouteTable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCStoreServer is the server API for RPCStore service.
type RPCStoreServer interface {
	StoreLoadMaxSeqsData(context.Context, *TLStoreLoadMaxSeqsData) (*MaxSeqsData, error)
	StoreSaveMaxSeq(context.Context, *TLStoreSaveMaxSeq) (*Int64V, error)
	StoreLoadRouteTable(context.Context, *TLStoreLoadRouteTable) (*Router, error)
	StoreSaveRouteTable(context.Context, *TLStoreSaveRouteTable) (*Bool2, error)
}

// UnimplementedRPCStoreServer can be embedded to have forward compatible implementations.
type UnimplementedRPCStoreServer struct {
}

func (*UnimplementedRPCStoreServer) StoreLoadMaxSeqsData(ctx context.Context, req *TLStoreLoadMaxSeqsData) (*MaxSeqsData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreLoadMaxSeqsData not implemented")
}
func (*UnimplementedRPCStoreServer) StoreSaveMaxSeq(ctx context.Context, req *TLStoreSaveMaxSeq) (*Int64V, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreSaveMaxSeq not implemented")
}
func (*UnimplementedRPCStoreServer) StoreLoadRouteTable(ctx context.Context, req *TLStoreLoadRouteTable) (*Router, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreLoadRouteTable not implemented")
}
func (*UnimplementedRPCStoreServer) StoreSaveRouteTable(ctx context.Context, req *TLStoreSaveRouteTable) (*Bool2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreSaveRouteTable not implemented")
}

func RegisterRPCStoreServer(s *grpc.Server, srv RPCStoreServer) {
	s.RegisterService(&_RPCStore_serviceDesc, srv)
}

func _RPCStore_StoreLoadMaxSeqsData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLStoreLoadMaxSeqsData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCStoreServer).StoreLoadMaxSeqsData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seqsvr.RPCStore/StoreLoadMaxSeqsData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCStoreServer).StoreLoadMaxSeqsData(ctx, req.(*TLStoreLoadMaxSeqsData))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCStore_StoreSaveMaxSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLStoreSaveMaxSeq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCStoreServer).StoreSaveMaxSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seqsvr.RPCStore/StoreSaveMaxSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCStoreServer).StoreSaveMaxSeq(ctx, req.(*TLStoreSaveMaxSeq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCStore_StoreLoadRouteTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLStoreLoadRouteTable)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCStoreServer).StoreLoadRouteTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seqsvr.RPCStore/StoreLoadRouteTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCStoreServer).StoreLoadRouteTable(ctx, req.(*TLStoreLoadRouteTable))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCStore_StoreSaveRouteTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLStoreSaveRouteTable)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCStoreServer).StoreSaveRouteTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seqsvr.RPCStore/StoreSaveRouteTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCStoreServer).StoreSaveRouteTable(ctx, req.(*TLStoreSaveRouteTable))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "seqsvr.RPCStore",
	HandlerType: (*RPCStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "store_loadMaxSeqsData",
			Handler:    _RPCStore_StoreLoadMaxSeqsData_Handler,
		},
		{
			MethodName: "store_saveMaxSeq",
			Handler:    _RPCStore_StoreSaveMaxSeq_Handler,
		},
		{
			MethodName: "store_loadRouteTable",
			Handler:    _RPCStore_StoreLoadRouteTable_Handler,
		},
		{
			MethodName: "store_saveRouteTable",
			Handler:    _RPCStore_StoreSaveRouteTable_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "seqsvr.tl.proto",
}

func (m *Bool2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bool2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bool2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLBoolFalse2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBoolFalse2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBoolFalse2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLBoolTrue2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBoolTrue2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBoolTrue2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Int32V) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int32V) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Int32V) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.V != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.V))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLInt32V) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInt32V) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInt32V) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Int64V) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int64V) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Int64V) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.V != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.V))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLInt64V) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInt64V) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInt64V) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaxSeqsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxSeqsData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxSeqsData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MaxSeqs) > 0 {
		dAtA6 := make([]byte, len(m.MaxSeqs)*10)
		var j5 int
		for _, num1 := range m.MaxSeqs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x22
	}
	if m.SetId != nil {
		{
			size, err := m.SetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLMaxSeqsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMaxSeqsData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMaxSeqsData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeAddrInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAddrInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeAddrInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLNodeAddrInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLNodeAddrInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLNodeAddrInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PerSetRouterTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerSetRouterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerSetRouterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeList) > 0 {
		for iNdEx := len(m.NodeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SetId != nil {
		{
			size, err := m.SetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLPerSetRouterTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLPerSetRouterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLPerSetRouterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Size2 != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Size2))
		i--
		dAtA[i] = 0x20
	}
	if m.IdBegin != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.IdBegin))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLRangeId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRangeId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRangeId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Router) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeList) > 0 {
		for iNdEx := len(m.NodeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Version != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRouter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRouter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouterNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouterNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SectionRanges) > 0 {
		for iNdEx := len(m.SectionRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SectionRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NodeAddr != nil {
		{
			size, err := m.NodeAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLRouterNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRouterNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRouterNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Router != nil {
		{
			size, err := m.Router.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Seq != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NodeAddr != nil {
		{
			size, err := m.NodeAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SetId != nil {
		{
			size, err := m.SetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLSetNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSetNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSetNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetNodeInfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetNodeInfoList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetNodeInfoList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeAddrs) > 0 {
		for iNdEx := len(m.NodeAddrs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeAddrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SetId != nil {
		{
			size, err := m.SetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLSetNodeInfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSetNodeInfoList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSetNodeInfoList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Void2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Void2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Void2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLVoid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLVoid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLVoid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLAllocFetchNextSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAllocFetchNextSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAllocFetchNextSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if m.Id != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAllocGetCurrentSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAllocGetCurrentSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAllocGetCurrentSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if m.Id != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLStoreLoadMaxSeqsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLStoreLoadMaxSeqsData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLStoreLoadMaxSeqsData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLStoreSaveMaxSeq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLStoreSaveMaxSeq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLStoreSaveMaxSeq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxSeq != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.MaxSeq))
		i--
		dAtA[i] = 0x20
	}
	if m.Id != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLStoreLoadRouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLStoreLoadRouteTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLStoreLoadRouteTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLStoreSaveRouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLStoreSaveRouteTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLStoreSaveRouteTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Router != nil {
		{
			size, err := m.Router.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediateRegisterAllocSvr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediateRegisterAllocSvr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediateRegisterAllocSvr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NodeAddr != nil {
		{
			size, err := m.NodeAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediateUnRegisterAllocSvr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediateUnRegisterAllocSvr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediateUnRegisterAllocSvr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NodeAddr != nil {
		{
			size, err := m.NodeAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeqsvrTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintSeqsvrTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSeqsvrTl(dAtA []byte, offset int, v uint64) int {
	offset -= sovSeqsvrTl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Bool2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLBoolFalse2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLBoolTrue2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Int32V) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.V != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.V))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInt32V) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Int64V) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.V != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.V))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInt64V) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaxSeqsData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.SetId != nil {
		l = m.SetId.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if len(m.MaxSeqs) > 0 {
		l = 0
		for _, e := range m.MaxSeqs {
			l += sovSeqsvrTl(uint64(e))
		}
		n += 1 + sovSeqsvrTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMaxSeqsData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeAddrInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLNodeAddrInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PerSetRouterTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.SetId != nil {
		l = m.SetId.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if len(m.NodeList) > 0 {
		for _, e := range m.NodeList {
			l = e.Size()
			n += 1 + l + sovSeqsvrTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLPerSetRouterTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RangeId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.IdBegin != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.IdBegin))
	}
	if m.Size2 != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Size2))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLRangeId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.Version != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Version))
	}
	if len(m.NodeList) > 0 {
		for _, e := range m.NodeList {
			l = e.Size()
			n += 1 + l + sovSeqsvrTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLRouter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouterNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.NodeAddr != nil {
		l = m.NodeAddr.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if len(m.SectionRanges) > 0 {
		for _, e := range m.SectionRanges {
			l = e.Size()
			n += 1 + l + sovSeqsvrTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLRouterNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.Seq != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Seq))
	}
	if m.Router != nil {
		l = m.Router.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.SetId != nil {
		l = m.SetId.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.NodeAddr != nil {
		l = m.NodeAddr.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSetNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetNodeInfoList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.SetId != nil {
		l = m.SetId.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if len(m.NodeAddrs) > 0 {
		for _, e := range m.NodeAddrs {
			l = e.Size()
			n += 1 + l + sovSeqsvrTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSetNodeInfoList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Void2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLVoid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAllocFetchNextSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.Id != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Id))
	}
	if m.Version != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAllocGetCurrentSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.Id != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Id))
	}
	if m.Version != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLStoreLoadMaxSeqsData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLStoreSaveMaxSeq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.Id != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Id))
	}
	if m.MaxSeq != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.MaxSeq))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLStoreLoadRouteTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLStoreSaveRouteTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.Router != nil {
		l = m.Router.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediateRegisterAllocSvr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.NodeAddr != nil {
		l = m.NodeAddr.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediateUnRegisterAllocSvr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSeqsvrTl(uint64(m.Constructor))
	}
	if m.NodeAddr != nil {
		l = m.NodeAddr.Size()
		n += 1 + l + sovSeqsvrTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSeqsvrTl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSeqsvrTl(x uint64) (n int) {
	return sovSeqsvrTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Bool2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bool2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bool2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBoolFalse2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_boolFalse2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_boolFalse2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Bool2{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBoolTrue2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_boolTrue2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_boolTrue2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Bool2{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int32V) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int32V: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int32V: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			m.V = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.V |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInt32V) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_int32V: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_int32V: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Int32V{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int64V) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64V: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64V: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			m.V = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.V |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInt64V) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_int64V: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_int64V: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Int64V{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxSeqsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxSeqsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxSeqsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetId == nil {
				m.SetId = &RangeId{}
			}
			if err := m.SetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSeqsvrTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MaxSeqs = append(m.MaxSeqs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSeqsvrTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSeqsvrTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSeqsvrTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MaxSeqs) == 0 {
					m.MaxSeqs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSeqsvrTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MaxSeqs = append(m.MaxSeqs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSeqs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMaxSeqsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_maxSeqsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_maxSeqsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MaxSeqsData{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeAddrInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAddrInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAddrInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLNodeAddrInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_nodeAddrInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_nodeAddrInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &NodeAddrInfo{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerSetRouterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerSetRouterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerSetRouterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetId == nil {
				m.SetId = &RangeId{}
			}
			if err := m.SetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeList = append(m.NodeList, &RouterNode{})
			if err := m.NodeList[len(m.NodeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLPerSetRouterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_perSetRouterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_perSetRouterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &PerSetRouterTable{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdBegin", wireType)
			}
			m.IdBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdBegin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size2", wireType)
			}
			m.Size2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRangeId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_rangeId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_rangeId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RangeId{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeList = append(m.NodeList, &RouterNode{})
			if err := m.NodeList[len(m.NodeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Router{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAddr == nil {
				m.NodeAddr = &NodeAddrInfo{}
			}
			if err := m.NodeAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SectionRanges = append(m.SectionRanges, &RangeId{})
			if err := m.SectionRanges[len(m.SectionRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRouterNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_routerNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_routerNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RouterNode{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Router == nil {
				m.Router = &Router{}
			}
			if err := m.Router.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_sequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_sequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Sequence{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetId == nil {
				m.SetId = &RangeId{}
			}
			if err := m.SetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAddr == nil {
				m.NodeAddr = &NodeAddrInfo{}
			}
			if err := m.NodeAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSetNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_setNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_setNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &SetNodeInfo{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetNodeInfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetNodeInfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetNodeInfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetId == nil {
				m.SetId = &RangeId{}
			}
			if err := m.SetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddrs = append(m.NodeAddrs, &NodeAddrInfo{})
			if err := m.NodeAddrs[len(m.NodeAddrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSetNodeInfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_setNodeInfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_setNodeInfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &SetNodeInfoList{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Void2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Void2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Void2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLVoid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_void: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_void: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Void2{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAllocFetchNextSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_alloc_fetchNextSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_alloc_fetchNextSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAllocGetCurrentSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_alloc_getCurrentSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_alloc_getCurrentSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLStoreLoadMaxSeqsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_store_loadMaxSeqsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_store_loadMaxSeqsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLStoreSaveMaxSeq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_store_saveMaxSeq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_store_saveMaxSeq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSeq", wireType)
			}
			m.MaxSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSeq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLStoreLoadRouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_store_loadRouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_store_loadRouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLStoreSaveRouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_store_saveRouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_store_saveRouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Router == nil {
				m.Router = &Router{}
			}
			if err := m.Router.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediateRegisterAllocSvr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_mediate_registerAllocSvr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_mediate_registerAllocSvr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAddr == nil {
				m.NodeAddr = &NodeAddrInfo{}
			}
			if err := m.NodeAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediateUnRegisterAllocSvr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_mediate_unRegisterAllocSvr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_mediate_unRegisterAllocSvr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAddr == nil {
				m.NodeAddr = &NodeAddrInfo{}
			}
			if err := m.NodeAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeqsvrTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeqsvrTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSeqsvrTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSeqsvrTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSeqsvrTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSeqsvrTl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSeqsvrTl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSeqsvrTl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSeqsvrTl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSeqsvrTl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSeqsvrTl = fmt.Errorf("proto: unexpected end of group")
)
